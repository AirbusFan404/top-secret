LICENSE.txt
``` plaintext
Public domain

```


README.md
``` markdown
The following README was generated by OpenAI's GPT-5-mini.

# Top Secret

**Top Secret** is a lightweight Python module that converts `dict[str, str]` objects into obfuscated strings called *top secrets*.

It is:

* Reversible
* Deterministic (based on a seed)
* Non–human-readable
* Not cryptographically secure

It is designed for situations where you want to discourage manual editing of configuration data without introducing full encryption complexity.

---

## ⚠️ Important Warnings

* Do **not** manually edit generated top secrets.
* Do **not** store sensitive information in top secrets.
* Do **not** change the seed unless all previously generated top secrets are backed up.

This project is **obfuscation**, not encryption.

---

## Installation

Install directly from GitHub:

'''bash
pip install git+https://github.com/AirbusFan404/top-secret.git
'''

Requires:

* Python ≥ 3.10
* `typing_extensions`

---

## Quick Start

### Basic Usage

'''python
import top_secret

data = {
    "foo": "bar",
    "spam": "eggs"
}

# Convert to obfuscated string
encoded = top_secret.dumps(data)

# Convert back to dictionary
decoded = top_secret.loads(encoded)

assert decoded == data
'''

---

### File-Based Usage

'''python
import top_secret

data = {"username": "admin", "mode": "debug"}

# Write to file
with open("config.secret", "w") as f:
    top_secret.dump(data, f)

# Read from file
with open("config.secret", "r") as f:
    restored = top_secret.load(f)
'''

---

## How It Works (Conceptual Overview)

Each character is:

1. Converted to its Unicode code point.
2. Transformed mathematically using a seed-derived multiplier and offset.
3. Converted to hexadecimal.
4. Substituted through a seeded cipher mapping.

Because all transformations depend on a shared seed, encoding and decoding remain consistent.

---

## Seed System

Top Secret derives its deterministic behavior from a seed. The seed is loaded using the following priority:

1. `SECRETSEED` environment variable (hex string)
2. `SECRETFILE` environment variable (path to file containing hex seed)
3. `~/.secretseed` file
4. If none exist, a new random seed is generated and saved to `~/.secretseed`

### Example: Setting a Seed

'''bash
export SECRETSEED=1a2b3c4d
'''

The seed must be a hexadecimal integer.

Changing the seed will make previously generated top secrets undecodable.

---

## API Reference

### Encoding

* `dumps(obj: dict[str, str]) -> str`
* `dump(obj: dict[str, str], fp: TextIO) -> int`

Raises:

* `TopSecretEncodeError`
* `SeedError`

---

### Decoding

* `loads(s: str) -> dict[str, str]`
* `load(fp: TextIO) -> dict[str, str]`

Raises:

* `TopSecretDecodeError`
* `SeedError`

---

## Running Tests

'''bash
python -m unittest discover
'''

---

## Project Structure

'''
top_secret.py         # Core module
test_top_secret.py    # Unit tests
pyproject.toml        # Project configuration
list_files.py         # Utility for listing repository files
LICENSE.txt           # Public domain license
'''

---

## Intended Use Cases

* Local configuration files
* Obfuscated user settings
* Preventing accidental edits
* Bridging human-readable formats and stronger security systems

---

## Not Intended For

* Password storage
* Secrets management
* Encryption
* Security-critical applications

---

## License

Public domain.

```


list_files.py
``` python
# Iterate over a sorted list of file names with their respective extensions
for i in sorted([
  "list_files.py python",  # Python script for listing files
  "test_top_secret.py python",  # Python script for testing top secret functionality
  "top_secret.py python",  # Main Python script for top secret operations
  "pyproject.toml toml",  # Configuration file for Python project
  "LICENSE.txt plaintext",  # Text file containing the license information
  "README.md markdown"  # Markdown file providing project documentation
]):
  # Split the string into file name and its extension
  fi, li = i.split(" ")

  # Print the file name
  print(fi)

  # Print the file extension in a code block format
  print("``` " + li)

  # Open the file in read mode
  with open(fi, "r") as f:
    # Read the file content and replace any ending code block syntax
    print(f.read().replace("\n```", "\n'''"))

  # Print the closing code block syntax
  print("```")

  # Print two new lines for better readability
  print()
  print()

```


pyproject.toml
``` toml
[project]
name = "top-secret"
version = "0.0.1"
description = "Encodes `dict[str, str]` objects into an obfuscated string. Read README.md for more information."
requires-python = ">=3.10"
dependencies = [ "typing_extensions>=4.11.0",]
readme = "README.md"
keywords = [ "encode", "decode", "obfuscate", "deobfuscate", "dictionary", "string", "json", "jsonify", "dejsonify",]
classifiers = [ "Development Status :: 5 - Production/Stable", "Intended Audience :: Developers", "License :: OSI Approved :: MIT License", "Programming Language :: Python :: 3.10", "Programming Language :: Python :: 3.11", "Programming Language :: Python :: 3.12", "Programming Language :: Python :: 3.13", "Programming Language :: Python :: 3.14", "Topic :: Software Development :: Libraries :: Python Modules", "Topic :: Utilities", "Typing :: Typed",]
[[project.authors]]
name = "Isaac Dunn"
email = "30stu225@lexingtonma.org"

[build-system]
requires = [ "setuptools>=61.0.0", "wheel>=0.43.0",]
build-backend = "setuptools.build_meta"

[project.license]
file = "LICENSE.txt"

[project.urls]
Homepage = "https://github.com/AirbusFan404/top-secret"
Documentation = "https://github.com/AirbusFan404/top-secret/blob/main/README.md"
Issues = "https://github.com/AirbusFan404/top-secret/issues"
Source = "https://github.com/AirbusFan404/top-secret.git"
Repository = "https://github.com/AirbusFan404/top-secret.git"
Changelog = "https://github.com/AirbusFan404/top-secret/commits/main"
Contact = "https://github.com/AirbusFan404/top-secret/issues"

[tool.setuptools]
py-modules = [ "top_secret",]

```


test_top_secret.py
``` python
import top_secret  # Importing the top_secret module for serialization and deserialization
import typing_extensions  # Importing typing_extensions for type hinting support
import unittest  # Importing the unittest module to create and run tests


class TestTopSecret(
    unittest.TestCase
):  # Defining a test case class that inherits from unittest.TestCase

  def test_roundtrip(
      self: typing_extensions.Self
  ) -> None:  # Test method for roundtrip serialization
    data = {
        "foo": "bar",
        "spam": "eggs"
    }  # Sample data to be serialized and deserialized
    # Asserting that the deserialized data matches the original data after serialization
    self.assertEqual(top_secret.loads(top_secret.dumps(data)), data)

  def test_roundtripf(
      self: typing_extensions.Self
  ) -> None:  # Test method for file-based roundtrip serialization
    data = {
        "foo": "bar",
        "spam": "eggs"
    }  # Sample data to be written to a file
    with open("test.txt", "w") as f:  # Opening a file in write mode
      top_secret.dump(data, f)  # Serializing and writing the data to the file
    with open("test.txt", "r") as f:  # Opening the same file in read mode
      # Asserting that the deserialized data from the file matches the original data
      self.assertEqual(top_secret.load(f), data)


if __name__ == "__main__":  # Checking if the script is being run directly
  unittest.main()  # Running the unit tests

```


top_secret.py
``` python
import os  # Importing the os module to interact with the operating system
import random  # Importing the random module to generate random numbers
import string  # Importing the string module for string constants
import typing_extensions  # Importing typing_extensions for type hinting

# Asserting that the module is not run directly
assert __name__ != "__main__", "This module is not meant to be run directly."

# Defining a character set for encoding/decoding
charset: str = string.ascii_letters + string.digits + string.punctuation


# Custom exception for seed errors
class SeedError(Exception):
  pass


# Function to retrieve a seed value
def _getseed() -> int:
  try:
    # Check if a seed is provided in the environment variable
    if "SECRETSEED" in os.environ:
      seed = int(os.environ["SECRETSEED"].strip(), 16)  # Convert hex to int
    # Check if a seed is provided in a file
    elif "SECRETFILE" in os.environ:
      with open(os.environ["SECRETFILE"], "r") as f:
        seed = int(f.read().strip(), 16)  # Convert hex to int
    # Check if a default seed file exists
    elif os.path.isfile(os.path.join(os.path.expanduser("~"), ".secretseed")):
      with open(os.path.join(os.path.expanduser("~"), ".secretseed"),
                "r") as f:
        seed = int(f.read().strip(), 16)  # Convert hex to int
    else:
      # Generate a random seed if none is found
      seed = random.randint(0, 2**31 - 1)
      with open(os.path.join(os.path.expanduser("~"), ".secretseed"),
                "w") as f:
        f.write(f"{seed:x}")  # Write the seed to the file in hex format
    return seed  # Return the seed value
  except Exception as e:
    # Raise a SeedError with the exception details
    raise SeedError(f"{type(e).__name__} {repr(str(e))}") from None


# Function to perform a calculation based on a number
def _calc(num: int) -> int:
  rng = random.Random(
      _getseed())  # Create a random number generator with the seed
  addby = rng.randint(-50, 50)  # Generate a random number to add
  multby = rng.randint(1, 20)  # Generate a random multiplier
  return num * multby + addby  # Return the calculated value


# Function to reverse the calculation
def _decalc(num: int) -> int:
  rng = random.Random(
      _getseed())  # Create a random number generator with the seed
  addby = rng.randint(-50, 50)  # Generate a random number to add
  multby = rng.randint(1, 20)  # Generate a random multiplier
  return (num - addby) // multby  # Return the reversed calculation


# Function to cipher a given text
def _cipher(text: str) -> str:
  rng = random.Random(
      _getseed())  # Create a random number generator with the seed
  cipher = dict(zip(string.hexdigits,
                    rng.sample(charset, 16)))  # Create a cipher mapping
  result = ""  # Initialize the result string
  for i in text:  # Iterate through each character in the text
    if i in cipher:  # Check if the character is in the cipher
      result += cipher[i]  # Append the ciphered character
    else:
      result += i  # Append the original character if not ciphered
  return result  # Return the ciphered text


# Function to decipher a given text
def _decipher(text: str) -> str:
  rng = random.Random(
      _getseed())  # Create a random number generator with the seed
  decipher = dict(zip(rng.sample(charset, 16),
                      string.hexdigits))  # Create a decipher mapping
  result = ""  # Initialize the result string
  for i in text:  # Iterate through each character in the text
    if i in decipher:  # Check if the character is in the decipher
      result += decipher[i]  # Append the deciphered character
    else:
      result += i  # Append the original character if not deciphered
  return result  # Return the deciphered text


# Custom exception for encoding errors
class TopSecretEncodeError(Exception):
  pass


# Function to serialize an object into a string format
def dumps(obj: typing_extensions.Dict[str, str]) -> str:
  try:
    result = []  # Initialize a list to hold the serialized key-value pairs
    for k, v in obj.items(
    ):  # Iterate through each key-value pair in the dictionary
      key = " ".join([_cipher(f"{_calc(ord(i)):x}")
                      for i in k])  # Cipher the key
      value = " ".join([_cipher(f"{_calc(ord(i)):x}")
                        for i in v])  # Cipher the value
      result.append(key + ": " +
                    value)  # Append the key-value pair to the result
    return "\n".join(result)  # Return the serialized string
  except Exception as e:
    # Raise a TopSecretEncodeError with the exception details
    raise TopSecretEncodeError(f"{type(e).__name__} {repr(str(e))}") from None


# Function to write serialized data to a file
def dump(obj: typing_extensions.Dict[str, str],
         fp: typing_extensions.TextIO) -> int:
  try:
    return fp.write(dumps(obj))  # Write the serialized data to the file
  except Exception as e:
    # Raise a TopSecretEncodeError with the exception details
    raise TopSecretEncodeError(f"{type(e).__name__} {repr(str(e))}") from None


# Custom exception for decoding errors
class TopSecretDecodeError(Exception):
  pass


# Function to deserialize a string back into a dictionary
def loads(s: str) -> typing_extensions.Dict[str, str]:
  try:
    result = {}  # Initialize an empty dictionary to hold the deserialized data
    for line in s.split("\n"):  # Split the string into lines
      if not line:  # Skip empty lines
        continue
      k, v = line.split(": ")  # Split the line into key and value
      key = "".join([
          chr(_decalc(int(_decipher(i), 16))) for i in k.split(" ")
      ])  # Decipher the key
      value = "".join([
          chr(_decalc(int(_decipher(i), 16))) for i in v.split(" ")
      ])  # Decipher the value
      result[key] = value  # Add the key-value pair to the result dictionary
    return result  # Return the deserialized dictionary
  except Exception as e:
    # Raise a TopSecretDecodeError with the exception details
    raise TopSecretDecodeError(f"{type(e).__name__} {repr(str(e))}") from None


# Function to load data from a file and deserialize it
def load(fp: typing_extensions.TextIO) -> typing_extensions.Dict[str, str]:
  try:
    return loads(fp.read())  # Read the file and return the deserialized data
  except Exception as e:
    # Raise a TopSecretDecodeError with the exception details
    raise TopSecretDecodeError(f"{type(e).__name__} {repr(str(e))}") from None

```


